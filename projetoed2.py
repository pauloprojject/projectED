# -*- coding: utf-8 -*-
"""ProjetoED2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m7cjca9CLUc5wNSFW2zfVq_KRzRYlhgW

# Tree Exception
"""

class BinaryTreeException(Exception):
  def __init__(self, mensagem):
    super().__init__(mensagem)

"""# Dado"""

class Dado:
  def __init__(self, id, nome, ano):
    self._nome = nome
    self._ano = ano
    self._id = id

  #get
  @property
  def nome(self):
    return self._nome

  #set
  @nome.setter
  def nome(self, novo):
    self._nome = novo

  #get
  @property
  def ano(self):
    return self._ano

  #set
  @ano.setter
  def ano(self, novo):
    self._ano = novo

  #get
  @property
  def id(self):
    return self._id

  #set
  @id.setter
  def id(self, novo):
    self._id = novo

  def __str__(self):
    saida = '[\n'
    saida += f' id: {self.id},\n filme: {self.nome},\n ano de lançamento: {self.ano}\n'
    saida += ']'
    return saida

"""# Nó"""

class No:
  def __init__(self, dado = None):
    self._dado = dado
    self._esq = None
    self._dir = None


  # get
  @property
  def dado(self):
    return self._dado
  
  # set
  @dado.setter
  def dado(self, novo):
    self._dado = novo

  # get
  @property
  def esq(self):
    return self._esq
  
  # set
  @esq.setter
  def esq(self, novo):
      self._esq = novo

  # get
  @property
  def dir(self):
    return self._dir
  
  # set
  @dir.setter
  def dir(self, novo):
    self._dir = novo

  #get
  @property
  def nome(self):
    return self._dado.nome

  #get
  @property
  def id(self):
    return self._dado.id

  #get
  @property
  def ano(self):
    return self._dado.ano
  
  def balanco(self):
    prof_esq = 0
    if self.esq:
      prof_esq = self.esq.profundidade()
    prof_dir = 0
    if self.dir:
      prof_dir = self.dir.profundidade()
    return prof_esq - prof_dir
      
  def profundidade(self):
    prof_esq = 0
    if self.esq:
      prof_esq = self.esq.profundidade()
    prof_dir = 0
    if self.dir:
      prof_dir = self.dir.profundidade()
    return 1 + max(prof_esq, prof_dir)

  def balanco_exec(self):
    a = self.balanco()
    if a > 1:
      if self.esq.balanco() < 0:
        self.esq = rotacao_esq(self.esq)
      self = rotacao_dir(self)
      return self
    elif a < -1:
      if self.dir.balanco() > 0:
        self.dir = rotacao_dir(self.dir)
      self = rotacao_esq(self)
      return self
    else:
      return self

  ######## <stack_overflow>
  def display(self):
        lines, *_ = self._display_aux()
        for line in lines:
            print(line)

  def _display_aux(self):
      """Returns list of strings, width, height, and horizontal coordinate of the root."""
      # No child.
      if self.dir is None and self.esq is None:
          line = '%s' % self.dado.id
          width = len(line)
          height = 1
          middle = width // 2
          return [line], width, height, middle
      # Only esq child.
      if self.dir is None:
          lines, n, p, x = self.esq._display_aux()
          s = '%s' % self.dado.id
          u = len(s)
          first_line = (x + 1) * ' ' + (n - x - 1) * '_' + s
          second_line = x * ' ' + '/' + (n - x - 1 + u) * ' '
          shifted_lines = [line + u * ' ' for line in lines]
          return [first_line, second_line] + shifted_lines, n + u, p + 2, n + u // 2
      # Only dir child.
      if self.esq is None:
          lines, n, p, x = self.dir._display_aux()
          s = '%s' % self.dado.id
          u = len(s)
          first_line = s + x * '_' + (n - x) * ' '
          second_line = (u + x) * ' ' + '\\' + (n - x - 1) * ' '
          shifted_lines = [u * ' ' + line for line in lines]
          return [first_line, second_line] + shifted_lines, n + u, p + 2, u // 2
      # Two children.
      esq, n, p, x = self.esq._display_aux()
      dir, m, q, y = self.dir._display_aux()
      s = '%s' % self.dado.id
      u = len(s)
      first_line = (x + 1) * ' ' + (n - x - 1) * '_' + s + y * '_' + (m - y) * ' '
      second_line = x * ' ' + '/' + (n - x - 1 + u + y) * ' ' + '\\' + (m - y - 1) * ' '
      if p < q:
          esq += [n * ' '] * (q - p)
      elif q < p:
          dir += [m * ' '] * (p - q)
      zipped_lines = zip(esq, dir)
      lines = [first_line, second_line] + [a + u * ' ' + b for a, b in zipped_lines]
      return lines, n + m + u, max(p, q) + 2, n + u // 2

######## </stack_overflow>

"""# Tree"""

class BinaryTree:
  def inOrder(self, arvore):
    if arvore != None:
      self.inOrder(arvore.esq)
      print(arvore.dado.id, end=' ')
      self.inOrder(arvore.dir)

def rotacao_dir(arvore):
    aux = arvore.esq
    arvore.esq = aux.dir
    aux.dir = arvore

    return aux  

def rotacao_esq(arvore):
    aux = arvore.dir
    arvore.dir = aux.esq
    aux.esq = arvore

    return aux


def insere(raiz, no):
  if raiz.dado.id < no.dado.id:
    if raiz.dir == None:
      raiz.dir = no
    else:
      insere(raiz.dir, no)
  else:
    if raiz.esq == None:
      raiz.esq = no
    else:
      insere(raiz.esq, no)


def buscaID(raiz, chave):
  if type(chave) != int:
    raise BinaryTreeException('apenas números')
  if raiz.dado == None:
    raise BinaryTreeException('Árvore vazia')
  atual = raiz
  while atual.id != chave:
    if chave < atual.id:
      atual = atual.esq
    else:
      atual = atual.dir
    if atual == None:
      return 'chave não encontrada'
  return f'Nome: {atual.dado.nome}, Ano: {atual.dado.ano}'

def buscaANO(raiz, chave):
  if raiz != None:
    buscaANO(raiz.dir, chave)
    if raiz.dado.ano == chave:
      print(raiz.dado)
    else:
      return 'chave não encontrada'
    buscaANO(raiz.esq, chave)

"""# Menu"""

nomes = []
print('Adiciona o nó raiz:')
nome = input("Insira o nome do filme: ")
nomes.append(nome)
idd = int(input("Insira o ID do filme: "))
ano = int(input("Insira o ano de lançamento do filme: "))
filme = Dado(idd,nome,ano)
raiz = No(filme)
while True:
  menu = int(input("Selecione uma alternativa:\n(1) Inserir\n(2) Buscar por ID\n(3) Buscar filme por ano\n(4) Listar filmes em ordem alfabética\n(5) Altura da árvore\n(6) Exibir a árvore\n(7) Sair\n"))
  if menu == 7:
    break
  if menu == 1:
    while True:
      nome = input("Insira o nome do filme: ")
      nomes.append(nome)
      idd = int(input("Insira o ID do filme: "))
      ano = int(input("Insira o ano de lançamento do filme: "))
      filme = Dado(idd,nome,ano)
      add = No(filme)
      insere(raiz, add)
      raiz = raiz.balanco_exec()
      loop = input("Deseja adicionar outro filme? S/N \n").upper()
      if loop == 'N':
        break
  if menu == 2:
    while True:
      pesq = int(input("Insira o ID do filme: "))
      print(f'O filme do id {pesq} é:')
      print(buscaID(raiz, pesq))
      loop = input("Deseja pesquisar outro filme? N para negativo \n").upper()
      if loop == 'N':
        break
  if menu == 3:
    while True:
      pesq = int(input("Insira o ano de lançamento do filme: "))
      print('O(s) filme(s) desse ano é(são):')
      buscaANO(raiz, pesq)
      loop = input("Deseja pesquisar outro filme? N para negativo \n").upper()
      if loop == "N":
        break
  if menu == 4:
    print(sorted(nomes))
  if menu == 5:
    print('A altura da árvore é: ' + str(raiz.profundidade()))
  if menu == 6:
    opc = int(input("(1) Modo avaliação\n(2) Modo bonito \n"))
    if opc == 1:
      tree = BinaryTree()
      tree.inOrder(raiz)
    elif opc == 2:
      raiz.display()
    else:
      print("opção invalida")